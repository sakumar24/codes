#include<iostream>#include<stdlib.h>#include<climits>using namespace std;struct BSTNode{	int data;	struct BSTNode* left;	struct BSTNode* right;};struct BSTNode* newNode(int data){	struct BSTNode* n = (struct BSTNode*) malloc(sizeof (struct BSTNode));	if(n == NULL)	{		cout<<"Can't allocate memory for new node."<<endl;		exit(1);	}	n->data = data;	n->left = NULL;	n->right = NULL;		return n;} void insert(struct BSTNode** Root, int data){	struct BSTNode* root = *Root;	if(root == NULL)		*Root = newNode(data);	else	{		while(1)		{			if(root->data > data)			{				if(root->left == NULL)				{					root->left = newNode(data);					break;				}				else					root = root->left;			}			else if(root->data < data)			{				if(root->right == NULL)				{					root->right = newNode(data);					break;				}				else					root = root->right;			}			else			{				cout<<"Node already in the tree."<<endl;				break;			}		}	}}void printInorder(struct BSTNode* root){	if(root)	{		printInorder(root->left);		cout<<root->data<<" ";		printInorder(root->right);	}}struct BSTNode* getMaxNode(struct BSTNode* root){	int m;	if(root == NULL)	{		cout<<"Root is NULL."<<endl;		return NULL;	}	while(root->right)		root = root->right;	return root;}struct BSTNode* getMinNode(struct BSTNode* root){	int m;	if(root == NULL)	{		cout<<"Root is NULL."<<endl;		return NULL;	}	while(root->left)		root = root->left;	return root;}struct BSTNode* find(struct BSTNode* root,int data){	if(root == NULL)		return NULL;	else	{		cout<<"Current node:"<<root->data<<endl;		if(root->data == data)			return root;		else if(root->data < data)			find(root->right,data);		else			find(root->left,data);			}}struct BSTNode* deleteNode(struct BSTNode* root,int data){	if(root == NULL)	{		cout<<"Node not in Tree."<<endl;		return NULL;	}	else if(root->data > data)		root->left = deleteNode(root->right,data);	else if(root->data < data)		root->right = deleteNode(root->right,data);	else	{			struct BSTNode* temp;		if(root->left && root->right)		{			temp = getMinNode(root->right);			root->data = temp->data;			root->right = deleteNode(root->right,temp->data);					}		else		{			temp = root;			if(root->right)					root = root->right;			if(root->left)				root = root->right;						free(temp);			temp = NULL;		}	}	return root;}struct BSTNode* kthSmallest(struct BSTNode* root,int k){	static int i=1;	if(root == NULL)		return NULL;	else	{		struct BSTNode* left = kthSmallest(root->left,k);		if(left)			return left;		if(i++==k)			return root;		return kthSmallest(root->right,k);	}}void floorCeil(struct BSTNode* root,int x,int *floor,int *ceil){	if(root == NULL)		return;	if(root->data > x)	{		if(*ceil > root->data)			*ceil = root->data;		floorCeil(root->left,x,floor,ceil);	}	else if(root->data < x)	{		if(*floor < root->data)			*floor = root->data;		floorCeil(root->right,x,floor,ceil);	}	else	{		*floor = *ceil = root->data;	}}void printRange(struct BSTNode* root,int k1,int k2){	if(root == NULL)		return;	if(root->data > k2)		// root is greater than range, so will be all in right, so just go to left.		printRange(root->left,k1,k2);	else if(root->data < k1)	// root is smaller than range, so will be all in left, so just go to right.		printRange(root->right,k1,k2);	else	// root is in range	{		cout<<root->data<<" ";		printRange(root->left,k1,k2);		printRange(root->right,k1,k2);	}}int main(){	int data;	struct BSTNode* root = NULL;	cout<<"Enter nodes followed by -1 to crate BST:";	cin>>data;	while(data != -1)	{		insert(&root,data);		cin>>data;	}		int t=1;	while(t)	{		int option;		cout<<"\n\n\t 1 -> Exit\n\t 2 -> Max \n\t 3 -> Min \n\t 4 -> Find \n\t 5 -> Delete \n\t 6 -> Print Inorder\n\t 7 -> Insert node";		cout<<"\n\t 8 -> kth smallest \n\t 9 -> Find floor and ceil \n\t 10 -> Print in range"<<endl;		cin>>option;		switch(option)		{			case 1:				t=0;			break;						case 2:			{				struct BSTNode* max = getMaxNode(root);				if(max)					cout<<"Max node-data:"<<max->data<<endl;			break;			}			case 3:			{				struct BSTNode* min = getMinNode(root);				if(min)					cout<<"Min node-data:"<<min->data<<endl;			break;			}			case 4:			{				int d;				cout<<"Enter data to search node:";				cin>>d;				if(! find(root,d))					cout<<"Node not found."<<endl;				else					cout<<"Node found in tree."<<endl;			break;			}			case 5:			{				int d;				cout<<"Enter data of node to delete:";				cin>>d;				root = deleteNode(root,d);			break;			}			case 6:			{				cout<<"Inorder traversal:";				printInorder(root);				cout<<endl;			}			break;			case 7:			{				cout<<"Enter data:";				cin>>data;				insert(&root,data);			}			break;					case 8:			{				int k;				cout<<"Enter k:";				cin>>k;				struct BSTNode* ans = kthSmallest(root,k);				if(ans)					cout<<k <<"th smallest element:"<<ans->data<<endl;				else					cout<<"Invalid k value"<<endl;			}			break;			case 9:			{				int x;				cout<<"Enter value for x:";				cin>>x;				int floor = INT_MIN;				int ceil = INT_MAX;				floorCeil(root,x,&floor,&ceil);				cout<<"Floor value:"<<floor<<" Ceil value:"<<ceil<<endl;			}			break;			case 10:			{				int k1,k2;				cout<<"Enter k1 and k2:";				cin>>k1>>k2;				if(k1>k2)				{					int t = k1;					k1 = k2;					k2 = t;				}				printRange(root,k1,k2);				cout<<endl;			}			break;		}	}return 0;}